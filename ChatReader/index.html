<!--
WhatsApp Chat Viewer (single-file) - Optimized
Features added in this version:
 - Uses fflate (fast unzip) to speed up large archives
 - Reads the ZIP once (single arrayBuffer -> Uint8Array) to avoid duplicate copies
 - Lazy-loads attachments on demand (click or when scrolled into view)
 - Incremental rendering (batch rendering) so UI stays responsive
 - Drag & drop support
 - All client-side; suitable for GitHub Pages

Usage:
 - Upload a ZIP containing _chat.txt (or any chat .txt) and all attachments in the same folder.
 - The page will parse chat text quickly and list messages. Click an attachment placeholder to load it.

-->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WhatsApp Chat Viewer — Fast</title>
  <script src="https://unpkg.com/fflate@0.8.6/umd/index.js"></script>
  <style>
    :root{--bg:#0f1720;--muted:#9aa4b2;--accent:#6ee7b7}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial}
    body{background:linear-gradient(180deg,#071021 0%, #081827 100%);color:#e6eef6;padding:18px}
    .container{max-width:1100px;margin:0 auto}
    header{display:flex;gap:12px;align-items:center;margin-bottom:18px}
    .logo{width:48px;height:48px;background:linear-gradient(135deg,#72e0b6,#6b8bf3);border-radius:8px;display:flex;align-items:center;justify-content:center;font-weight:700;color:#012}
    h1{font-size:20px;margin:0}
    .meta{color:var(--muted);font-size:13px}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:10px;padding:12px}
    .message{display:flex;gap:10px;padding:10px;border-radius:8px;margin-bottom:6px}
    .avatar{width:40px;height:40px;border-radius:50%;background:#133243;display:flex;align-items:center;justify-content:center;font-weight:600;color:var(--accent);flex-shrink:0}
    .bubble{background:rgba(255,255,255,0.03);padding:8px;border-radius:8px;max-width:78%}
    .metaRow{display:flex;gap:8px;align-items:center;margin-bottom:6px}
    .sender{font-weight:700}
    .time{color:var(--muted);font-size:12px}
    img.attachment{max-width:320px;border-radius:6px;margin-top:6px;display:block}
    video{max-width:420px;margin-top:6px;border-radius:6px}
    .toolbar{display:flex;gap:8px;margin-bottom:10px}
    .search{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:transparent;color:inherit}
    .att-thumb{width:110px;height:80px;background:#06101a;border-radius:6px;display:flex;align-items:center;justify-content:center;overflow:hidden}
    .btn{background:#0f1724;padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);color:inherit;text-decoration:none}
    footer{margin-top:18px;color:var(--muted);font-size:13px;text-align:center}
    .progress{font-size:13px;color:var(--muted);margin-bottom:8px}
    @media (max-width:700px){.avatar{display:none}.bubble{max-width:100%}}
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div class="logo">WA</div>
      <div>
        <h1>WhatsApp Chat Viewer — Fast</h1>
        <div class="meta">Upload a ZIP containing <code>_chat.txt</code> and attachments (same folder). Uses fflate for fast unzip.</div>
      </div>

      <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
        <label class="btn">Choose ZIP <input id="zipfile" type="file" accept=".zip" style="display:none"></label>
        <button id="openZip" class="btn">Open ZIP</button>
        <button id="downloadJson" class="btn" title="Download parsed JSON">Export JSON</button>
      </div>
    </header>

    <div class="card">
      <div class="toolbar">
        <input id="search" class="search" placeholder="Search messages or sender" />
        <select id="senderFilter" class="search"><option value="">All senders</option></select>
        <input id="dateFrom" type="date" class="search" />
        <input id="dateTo" type="date" class="search" />
        <button id="clearFilters" class="btn">Clear</button>
      </div>

      <div id="progress" class="progress">Drop a ZIP or click Open ZIP to start.</div>
      <div id="messages" aria-live="polite"></div>
    </div>

    <footer>Pure client-side — nothing is uploaded. Put this file on GitHub Pages to serve as a static viewer.</footer>
  </div>

<script>
// Fast WhatsApp Chat Viewer
// Uses fflate.unzipSync on a single Uint8Array (no double-copy). Lazy loads attachments and renders messages incrementally.

const zipInput = document.getElementById('zipfile');
const openBtn = document.getElementById('openZip');
const messagesEl = document.getElementById('messages');
const searchEl = document.getElementById('search');
const senderFilter = document.getElementById('senderFilter');
const dateFrom = document.getElementById('dateFrom');
const dateTo = document.getElementById('dateTo');
const clearFilters = document.getElementById('clearFilters');
const downloadJson = document.getElementById('downloadJson');
const progressEl = document.getElementById('progress');

let parsed = {messages:[], filesMap:{}}; // filesMap: filename -> {data:Uint8Array, name}
let observer = null;

openBtn.addEventListener('click', ()=> zipInput.click());
zipInput.addEventListener('change', (e)=>{ const f = e.target.files[0]; if(f) processZipFast(f); });
searchEl.addEventListener('input', renderFiltered);
senderFilter.addEventListener('change', renderFiltered);
dateFrom.addEventListener('change', renderFiltered);
dateTo.addEventListener('change', renderFiltered);
clearFilters.addEventListener('click', ()=>{searchEl.value='';senderFilter.value='';dateFrom.value='';dateTo.value='';renderMessagesInBatches(parsed.messages)});
downloadJson.addEventListener('click', ()=>{ const blob = new Blob([JSON.stringify(parsed, null, 2)], {type:'application/json'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href=url; a.download='chat_export.json'; document.body.appendChild(a); a.click(); a.remove(); });

async function processZipFast(file){
  progressEl.textContent = 'Reading ZIP (this may take a few seconds)...';
  // read once
  const ab = await file.arrayBuffer(); // read once into memory
  const u8 = new Uint8Array(ab);

  progressEl.textContent = 'Unzipping (fflate)...';
  // unzipSync returns an object { 'path/name': Uint8Array }
  let files;
  try{
    files = fflate.unzipSync(u8);
  }catch(err){
    progressEl.textContent = 'Unzip failed: ' + err.message;
    return;
  }

  progressEl.textContent = 'Indexing files...';
  // create a map from basename -> zipKey (first occurrence wins)
  const filesMap = {};
  for(const key of Object.keys(files)){
    const parts = key.split('/');
    const name = parts[parts.length-1];
    filesMap[name] = {data: files[key], zipPath:key};
  }

  // find likely chat text file
  const names = Object.keys(filesMap);
  const chatFileName = names.find(n=>n.toLowerCase().includes('_chat.txt'))
        || names.find(n=>n.toLowerCase().includes('chat') && n.toLowerCase().endsWith('.txt'))
        || names.find(n=>n.toLowerCase().endsWith('.txt'));
  if(!chatFileName){ progressEl.textContent = 'No chat .txt found in ZIP.'; return; }

  // decode chat text (assume UTF-8; fall back to windows-1252 if needed)
  let chatText;
  try{
    chatText = new TextDecoder('utf-8').decode(filesMap[chatFileName].data);
  }catch(e){
    try{ chatText = new TextDecoder('windows-1252').decode(filesMap[chatFileName].data); }catch(e2){ chatText = ''; }
  }

  progressEl.textContent = 'Parsing chat...';
  parsed = parseChat(chatText, filesMap);
  parsed.filesMap = filesMap; // store for lazy loads

  // create observer for lazy-loading attachments when they enter viewport
  if(observer) observer.disconnect();
  observer = new IntersectionObserver(handleIntersections, {root:null,rootMargin:'200px',threshold:0.01});

  progressEl.textContent = 'Rendering messages...';
  await renderMessagesInBatches(parsed.messages, 200);
  progressEl.textContent = 'Done — ' + parsed.messages.length + ' messages. Click an attachment to load it.';
  populateSenderFilter(parsed.messages);
}

function parseChat(text, filesMap){
  text = text.replace(/\r\n/g,'\n').replace(/\r/g,'\n');
  const lines = text.split('\n');
  const messages = [];

  const patterns = [
    /^\[(?<date>\d{1,2}\/\d{1,2}\/\d{2,4}),\s*(?<time>[^\]]+)\]\s*(?<sender>[^:]+):\s*(?<msg>.*)$/,
    /^(?<date>\d{1,2}\/\d{1,2}\/\d{2,4}),\s*(?<time>\d{1,2}:\d{2})(?:\s*[APMapm\.]{0,4})?\s*-\s*(?<sender>[^:]+):\s*(?<msg>.*)$/,
    /^(?<date>\d{1,2}\/\d{1,2}\/\d{2,4})\s*-\s*(?<sender>[^:]+):\s*(?<msg>.*)$/,
  ];

  let current = null;
  for(let line of lines){
    if(!line.trim()) continue;
    let matched = null;
    for(const p of patterns){ const m = line.match(p); if(m){ matched = m; break; } }
    if(matched && matched.groups){
      if(current) messages.push(current);
      const d = matched.groups.date.trim();
      const t = matched.groups.time? matched.groups.time.trim() : '';
      const sender = matched.groups.sender ? matched.groups.sender.trim() : 'Unknown';
      const msg = matched.groups.msg || '';
      const dt = parseDateTime(d, t);
      current = {dateRaw:d, timeRaw:t, datetime: dt, sender, text: msg, attachments: []};
      extractAttachedFiles(current, filesMap);
    } else {
      if(current) { current.text += '\n' + line; extractAttachedFiles(current, filesMap); }
      else { current = {dateRaw:null,timeRaw:null,datetime:null,sender:'Unknown',text:line,attachments:[]}; extractAttachedFiles(current, filesMap); }
    }
  }
  if(current) messages.push(current);
  messages.sort((a,b)=>{ if(a.datetime && b.datetime) return a.datetime - b.datetime; return 0; });
  return {messages};
}

function extractAttachedFiles(msgObj, filesMap){
  const attRegex = /<attached:\s*([^>]+)>/gi;
  let m;
  while((m = attRegex.exec(msgObj.text)) !== null){ const fname = m[1].trim(); if(!msgObj.attachments.includes(fname)) msgObj.attachments.push(fname); }
  const fileInline = msgObj.text.match(/([\w\-]+\.(?:jpg|jpeg|png|gif|mp4|mov|pdf|heic|webp|webm|mkv))/gi);
  if(fileInline){ fileInline.forEach(f=>{ if(!msgObj.attachments.includes(f)) msgObj.attachments.push(f); }); }
}

function parseDateTime(dateStr, timeStr){
  try{
    const parts = dateStr.split('/').map(s=>s.trim());
    if(parts.length>=3){ let day=parts[0], month=parts[1], year=parts[2]; if(year.length===2) year='20'+year; let time=timeStr||'00:00'; const ampmMatch = time.match(/(AM|PM|am|pm)/); let dateIso = `${year.padStart(4,'0')}-${month.padStart(2,'0')}-${day.padStart(2,'0')}T`; let t = time.replace(/\s*[APMapm\.]{1,4}/g,'').trim(); if(!t) t='00:00'; if(!t.includes(':')) t = t + ':00'; dateIso += t; let dt = new Date(dateIso); if(ampmMatch){ const ampm = ampmMatch[0].toLowerCase(); let hh = parseInt(t.split(':')[0],10); if(ampm==='pm' && hh<12) hh+=12; if(ampm==='am' && hh===12) hh=0; const mm = parseInt(t.split(':')[1]||'0',10); dt = new Date(parseInt(year,10), parseInt(month,10)-1, parseInt(day,10), hh, mm); } return dt; }
  }catch(e){}
  return null;
}

async function renderMessagesInBatches(messages, batchSize = 100){
  messagesEl.innerHTML = '';
  for(let i=0;i<messages.length;i+=batchSize){
    const slice = messages.slice(i, i+batchSize);
    const frag = document.createDocumentFragment();
    for(const m of slice){ frag.appendChild(renderMessage(m)); }
    messagesEl.appendChild(frag);
    // observe any placeholders in this batch
    attachObserverToPlaceholders();
    await new Promise(r=>setTimeout(r, 10));
  }
}

function renderMessages(messages){ // fallback
  messagesEl.innerHTML='';
  const frag = document.createDocumentFragment();
  for(const m of messages) frag.appendChild(renderMessage(m));
  messagesEl.appendChild(frag);
}

function renderMessage(m){
  const wrapper = document.createElement('div'); wrapper.className='message';
  const avatar = document.createElement('div'); avatar.className='avatar'; avatar.textContent = initials(m.sender || 'U');
  const bubble = document.createElement('div'); bubble.className='bubble';
  const metaRow = document.createElement('div'); metaRow.className='metaRow';
  const sender = document.createElement('div'); sender.className='sender'; sender.textContent = m.sender || 'Unknown';
  const time = document.createElement('div'); time.className='time'; time.textContent = m.datetime? formatDate(m.datetime) : (m.dateRaw||'');
  metaRow.appendChild(sender); metaRow.appendChild(time);
  bubble.appendChild(metaRow);
  const textEl = document.createElement('div'); textEl.innerHTML = linkify(escapeHtml(m.text || ''));
  bubble.appendChild(textEl);

  if(m.attachments && m.attachments.length){
    const attWrap = document.createElement('div'); attWrap.className='attachment-list';
    for(const fname of m.attachments){
      const aEl = makeAttachmentPlaceholder(fname);
      attWrap.appendChild(aEl);
    }
    bubble.appendChild(attWrap);
  }

  wrapper.appendChild(avatar); wrapper.appendChild(bubble);
  return wrapper;
}

function makeAttachmentPlaceholder(fname){
  const div = document.createElement('div');
  const lc = fname.toLowerCase();
  div.className='att-thumb';
  div.title = fname;

  // create a button/placeholder
  const btn = document.createElement('button'); btn.className='btn'; btn.style.width='100%'; btn.style.height='100%'; btn.textContent = 'Load: ' + fname; btn.dataset.fname = fname;
  div.appendChild(btn);

  // click to load
  btn.addEventListener('click', async (e)=>{
    btn.disabled = true; btn.textContent = 'Loading…';
    await loadAttachmentIntoElement(fname, div);
  });

  // mark for intersection observer (auto-load thumbnail)
  div.dataset.lazy = 'true';
  return div;
}

async function loadAttachmentIntoElement(fname, container){
  const filesMap = parsed.filesMap || {};
  const fileEntry = filesMap[fname] || filesMap[Object.keys(filesMap).find(k=>k.toLowerCase()===fname.toLowerCase())];
  if(!fileEntry){ container.innerHTML = '<div class="small">File not found: '+escapeHtml(fname)+'</div>'; return; }
  const u8 = fileEntry.data; // Uint8Array
  const blob = new Blob([u8]);
  const url = URL.createObjectURL(blob);
  container.innerHTML = '';
  if(fname.match(/\.(jpe?g|png|gif|webp|heic)$/i)){
    const img = document.createElement('img'); img.className='attachment'; img.src = url; container.appendChild(img);
  } else if(fname.match(/\.(mp4|mov|webm|mkv)$/i)){
    const v = document.createElement('video'); v.controls=true; v.src=url; container.appendChild(v);
  } else if(fname.match(/\.pdf$/i)){
    const a = document.createElement('a'); a.href=url; a.target='_blank'; a.textContent = fname; a.className='btn'; container.appendChild(a);
  } else {
    const a = document.createElement('a'); a.href=url; a.textContent = fname; a.download = fname; a.className='btn'; container.appendChild(a);
  }
}

function handleIntersections(entries){
  for(const e of entries){
    if(e.isIntersecting){
      const el = e.target;
      if(el.dataset.lazy === 'true'){
        // find button inside
        const btn = el.querySelector('button[data-fname]');
        if(btn){ btn.click(); }
        el.dataset.lazy = 'loaded';
        observer.unobserve(el);
      }
    }
  }
}

function attachObserverToPlaceholders(){
  if(!observer) return;
  const placeholders = document.querySelectorAll('.att-thumb[data-lazy="true"]');
  placeholders.forEach(p=>observer.observe(p));
}

function initials(name){ if(!name) return 'U'; const parts = name.trim().split(/\s+/); return (parts[0][0] || 'U') + (parts[1] ? parts[1][0] : ''); }
function formatDate(d){ try{return d.toLocaleString();}catch(e){return String(d);} }
function escapeHtml(s){ return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
function linkify(s){ return s.replace(/(https?:\/\/[^\s]+)/g, '<a href="$1" target="_blank">$1</a>').replace(/www\.[^\s]+/g, (m)=>'<a href="https://'+m+'" target="_blank">'+m+'</a>'); }

function populateSenderFilter(messages){ const senders = Array.from(new Set(messages.map(m=>m.sender))).sort(); senderFilter.innerHTML = '<option value="">All senders</option>' + senders.map(s=>`<option value="${escapeHtml(s)}">${escapeHtml(s)}</option>`).join(''); }

function renderFiltered(){
  const q = searchEl.value.toLowerCase();
  const sender = senderFilter.value;
  const from = dateFrom.value ? new Date(dateFrom.value) : null;
  const to = dateTo.value ? new Date(dateTo.value) : null;
  const filtered = parsed.messages.filter(m=>{
    if(sender && m.sender!==sender) return false;
    if(q){ if(!( (m.text||'').toLowerCase().includes(q) || (m.sender||'').toLowerCase().includes(q) || (m.attachments||[]).join(' ').toLowerCase().includes(q) )) return false; }
    if(from && m.datetime){ if(m.datetime < from) return false; }
    if(to && m.datetime){ const dayEnd = new Date(to); dayEnd.setDate(dayEnd.getDate()+1); if(m.datetime >= dayEnd) return false; }
    return true;
  });
  renderMessagesInBatches(filtered, 150);
}

// drag & drop
window.addEventListener('dragover', e=>{ e.preventDefault(); });
window.addEventListener('drop', async (e)=>{ e.preventDefault(); const f = e.dataTransfer.files[0]; if(f && f.name.toLowerCase().endsWith('.zip')){ await processZipFast(f); }});

</script>
</body>
</html>
