<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WhatsApp Chat Viewer</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #e5ddd5;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #container {
            width: 100%;
            max-width: 800px;
            margin: 20px auto;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 90vh;
        }

        #dropzone {
            padding: 40px;
            text-align: center;
            border: 2px dashed #ccc;
            border-radius: 8px;
            margin: 20px;
            cursor: pointer;
            background-color: #fafafa;
        }
        #dropzone:hover {
            background-color: #f0f0f0;
        }
        #fileInput {
            display: none;
        }

        #controls {
            padding: 10px 20px;
            border-bottom: 1px solid #eee;
            background: #f5f5f5;
            text-align: center;
        }

        #controls label {
            font-weight: bold;
            margin-right: 10px;
        }

        #chat-window {
            flex-grow: 1;
            overflow-y: auto;
            padding: 20px;
            background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAMAAAC5zwKfAAAAAXNSR0IB2cksfwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAFQTFRFAAAA9ubYyAAAAAFiS0dEAIgFHUgAAAAJcEhZcwAAAEgAAABIAEbJazYAAABGSURBVHic7cEBCQAACAOw/V/LgwwsQQgBvLp1cZtQ5fRShSIdUKQjFClHpIRIKZFSImVECqVERAlRRIiIECHyL40BAAD//wMA+gAq13kG3wAAAABJRU5ErkJggg==');
            background-color: #E5DDD5;
        }

        .message {
            display: flex;
            margin-bottom: 10px;
        }

        .message-bubble {
            max-width: 70%;
            padding: 10px 15px;
            border-radius: 18px;
            position: relative;
            word-wrap: break-word;
        }

        .message-content {
            white-space: pre-wrap;
        }

        .message .author {
            font-size: 0.8em;
            font-weight: bold;
            margin-bottom: 4px;
            color: #333;
        }
        
        /* Assigning colors to users */
        .message[data-author-id="0"] .author { color: #d9534f; }
        .message[data-author-id="1"] .author { color: #5bc0de; }
        .message[data-author-id="2"] .author { color: #5cb85c; }
        .message[data-author-id="3"] .author { color: #f0ad4e; }
        .message[data-author-id="4"] .author { color: #0275d8; }
        .message[data-author-id="5"] .author { color: #6a1b9a; }
        .message[data-author-id="6"] .author { color: #ad1457; }
        .message[data-author-id="7"] .author { color: #d84315; }
        /* Add more colors as needed */


        .message.sent {
            margin-left: auto;
        }

        .message.sent .message-bubble {
            background-color: #dcf8c6;
            border-top-right-radius: 8px;
        }

        .message.received {
            margin-right: auto;
        }

        .message.received .message-bubble {
            background-color: #ffffff;
            border-top-left-radius: 8px;
        }

        .message.system {
            width: 100%;
            text-align: center;
            margin: 10px 0;
            justify-content: center;
        }

        .message.system .message-bubble {
            background-color: #e1f2fb;
            color: #555;
            font-size: 0.9em;
            padding: 5px 12px;
            max-width: 90%;
        }

        .timestamp {
            font-size: 0.75em;
            color: #999;
            margin-top: 5px;
            text-align: right;
        }
        
        .message.sent .timestamp {
            text-align: right;
        }

        .message.received .timestamp {
            text-align: right;
        }

        .message.system .timestamp {
            display: none; /* System messages already have time in them */
        }
        
        .media-attachment {
            cursor: pointer;
            margin-top: 5px;
        }
        
        .media-attachment img,
        .media-attachment video {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            display: block;
        }
        
        .file-attachment {
            display: flex;
            align-items: center;
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
            margin-top: 5px;
            text-decoration: none;
            color: #333;
        }
        
        .file-attachment:hover {
            background-color: #eee;
        }
        
        .file-icon {
            font-size: 24px;
            margin-right: 10px;
        }
        
        .file-info {
            display: flex;
            flex-direction: column;
        }
        
        .file-name {
            font-weight: bold;
        }
        
        .file-size {
            font-size: 0.8em;
            color: #777;
        }

        #loader {
            text-align: center;
            padding: 20px;
            font-style: italic;
            color: #888;
        }
        
        #status-bar {
            padding: 8px 12px;
            background-color: #075E54;
            color: white;
            font-size: 0.9em;
            text-align: center;
        }
        
        #progress-container {
            width: 100%;
            padding: 20px;
            box-sizing: border-box;
            display: none; /* Hidden by default */
        }
        
        #progress-bar {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            border: none;
            border-radius: 4px;
            overflow: hidden;
        }
        
        #progress-bar::-webkit-progress-bar {
            background-color: #eee;
        }
        
        #progress-bar::-webkit-progress-value {
            background-color: #075E54;
        }
        
        #progress-bar::-moz-progress-bar {
            background-color: #075E54;
        }
    </style>
</head>
<body>

    <div id="container">
        
        <div id="controls">
            <label for="fileInput">Select your exported WhatsApp .zip file:</label>
            <input type="file" id="fileInput" accept=".zip" />
            <button onclick="document.getElementById('fileInput').click()">Browse</button>
        </div>

        <div id="progress-container">
            <progress id="progress-bar" value="0" max="100"></progress>
        </div>

        <div id="chat-window">
            <div id="dropzone">
                <p>Drag & Drop your WhatsApp .zip file here or use the "Browse" button.</p>
                <p style="font-size: 0.8em; color: #777;">(Everything is processed 100% in your browser. Nothing is uploaded.)</p>
            </div>
        </div>

        <div id="status-bar">Ready</div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/unzipit@1.4.3/dist/unzipit.min.js"></script>
    
    <script>
        // --- Constants and State ---
        const BATCH_SIZE = 50; // Number of messages to render at a time
        let allMessages = [];
        let zipFileEntries = {};
        let userColors = new Map();
        let colorIndex = 0;
        let renderedMessagesCount = 0;
        let intersectionObserver;

        // --- DOM Elements ---
        const fileInput = document.getElementById('fileInput');
        const dropZone = document.getElementById('dropzone');
        const chatWindow = document.getElementById('chat-window');
        const progressBar = document.getElementById('progress-bar');
        const progressContainer = document.getElementById('progress-container');
        const statusBar = document.getElementById('status-bar');

        // --- Event Listeners ---
        fileInput.addEventListener('change', handleFileSelect);
        dropZone.addEventListener('dragover', handleDragOver);
        dropZone.addEventListener('dragleave', handleDragLeave);
        dropZone.addEventListener('drop', handleFileSelect);

        // --- Functions ---

        /**
         * Handles file selection from either drag-and-drop or file input.
         */
        async function handleFileSelect(event) {
            event.preventDefault();
            event.stopPropagation();
            
            dropZone.style.display = 'none';
            progressContainer.style.display = 'block';
            statusBar.textContent = 'Processing...';

            const file = event.dataTransfer ? event.dataTransfer.files[0] : event.target.files[0];

            if (!file || !file.name.endsWith('.zip')) {
                updateStatus('Error: Please select a .zip file.', true);
                resetUI();
                return;
            }

            try {
                updateStatus('Unzipping file... (This may take a moment for large files)');
                
                // Use unzipit to read the zip file
                const { entries } = await unzipit.unzip(file, {
                    onprogress: (event) => {
                        const percent = (event.loaded / event.total) * 100;
                        progressBar.value = percent;
                    }
                });
                
                zipFileEntries = entries;
                
                const chatFileName = Object.keys(zipFileEntries).find(name => name.endsWith('_chat.txt'));
                
                if (!chatFileName) {
                    throw new Error('Could not find _chat.txt in the zip file.');
                }

                updateStatus('Parsing chat file...');
                const chatText = await zipFileEntries[chatFileName].text();
                
                allMessages = parseChatText(chatText);
                
                // Clear chat window for new content
                chatWindow.innerHTML = ''; 
                
                // Reset rendering state
                renderedMessagesCount = 0;
                userColors.clear();
                colorIndex = 0;
                
                // Add a "loader" element at the top for infinite scroll
                const topLoader = document.createElement('div');
                topLoader.id = 'top-loader';
                chatWindow.appendChild(topLoader);

                // Initial render of the *last* messages
                await renderMoreMessages(true); // <-- CHANGED: Added await
                
                // Set up intersection observer to load more when scrolling to top
                setupIntersectionObserver();
                
                updateStatus(`Loaded ${allMessages.length} messages.`);

            } catch (err) {
                console.error('Error processing file:', err);
                updateStatus(`Error: ${err.message}`, true);
                resetUI();
            } finally {
                progressContainer.style.display = 'none';
            }
        }

        /**
         * Parses the raw text content of _chat.txt into a structured array.
         */
        function parseChatText(text) {
            const lines = text.split('\n');
            const messages = [];
            // Regex to match the start of a new message line
            // [DD/MM/YY, HH:MM:SS] Author: Message
            const messageStartRegex = /^\[(\d{1,2}\/\d{1,2}\/\d{2,4}), (\d{1,2}:\d{2}:\d{2}\s[APM]{2})\] (.*?): ([\s\S]*)/;
            // Regex for system messages (e.g., "You joined", "X changed the group icon")
            const systemMessageRegex = /^\[(\d{1,2}\/\d{1,2}\/\d{2,4}), (\d{1,2}:\d{2}:\d{2}\s[APM]{2})\] ([\s\S]+?)(?=^\[\d{1,2}\/\d{1,2}\/\d{2,4},|\z)/m;

            let currentMessage = null;

            for (const line of lines) {
                const match = line.match(messageStartRegex);

                if (match) {
                    // This is a new message line
                    if (currentMessage) {
                        messages.push(currentMessage); // Save the previous message
                    }
                    
                    const [_, date, time, author, message] = match;
                    
                    if (author === 'You') {
                        // Let's handle "You" specifically for styling
                         currentMessage = {
                            date,
                            time,
                            author: "You",
                            message: message.trim(),
                            type: 'user'
                        };
                    } else if (message.includes('<attached:')) {
                         // This is a media message
                         currentMessage = {
                            date,
                            time,
                            author,
                            message: message.trim(),
            
                            type: 'media'
                        };
                    } else {
                        // Standard text message
                        currentMessage = {
                            date,
                            time,
                            author,
                            message: message.trim(),
                            type: 'text'
                        };
                    }
                } else if (line.match(systemMessageRegex) && !currentMessage) {
                    // This is a system message (like "User joined")
                     messages.push({
                        date: '', // System messages might not always have a sender, but we'll parse time from context
                        time: '',
                        author: 'System',
                        message: line.trim(),
                        type: 'system'
                    });
                    currentMessage = null; // Reset current message
                }
                 else if (currentMessage) {
                    // This is a continuation of the previous message (multi-line)
                    currentMessage.message += '\n' + line.trim();
                }
            }

            // Push the last message
            if (currentMessage) {
                messages.push(currentMessage);
            }

            return messages;
        }

        /**
         * Renders the next batch of messages.
         * @param {boolean} initialLoad - If true, scroll to the bottom after loading.
         */
        async function renderMoreMessages(initialLoad = false) { // <-- CHANGED: Added async
            updateStatus(`Rendering messages ${renderedMessagesCount} to ${Math.min(renderedMessagesCount + BATCH_SIZE, allMessages.length)}...`);

            const fragment = document.createDocumentFragment();
            const startIndex = Math.max(0, allMessages.length - renderedMessagesCount - BATCH_SIZE);
            const endIndex = allMessages.length - renderedMessagesCount;

            // Stop observing while we add new elements
            if (intersectionObserver) intersectionObserver.disconnect();

            for (let i = startIndex; i < endIndex; i++) {
                const messageData = allMessages[i];
                const messageEl = await createMessageElement(messageData); // <-- CHANGED: Added await
                fragment.appendChild(messageEl);
            }

            const topLoader = document.getElementById('top-loader');
            chatWindow.insertBefore(fragment, topLoader.nextSibling); // Insert before the loader
            
            renderedMessagesCount += (endIndex - startIndex);

            if (initialLoad) {
                // Scroll to the bottom on the very first load
                chatWindow.scrollTop = chatWindow.scrollHeight;
            } else {
                // Keep scroll position stable when loading older messages
                const firstNewMessage = chatWindow.children[1]; // [0] is the loader
                if (firstNewMessage) {
                    firstNewMessage.scrollIntoView({ block: 'start' });
                }
            }

            // Re-observe the loader if there are more messages
            if (renderedMessagesCount < allMessages.length) {
                if (intersectionObserver) {
                    intersectionObserver.observe(topLoader);
                }
            } else {
                topLoader.style.display = 'none'; // No more messages to load
                updateStatus(`All ${allMessages.length} messages loaded.`);
            }
        }
        
        /**
         * Sets up the IntersectionObserver to trigger loading more messages
         * when the top of the chat window is reached.
         */
        function setupIntersectionObserver() {
            const options = {
                root: chatWindow,
                rootMargin: '0px',
                threshold: 0.1
            };

            // <-- CHANGED: Made the callback async
            intersectionObserver = new IntersectionObserver(async (entries) => {
                if (entries[0].isIntersecting) {
                    // Load more messages when the top loader becomes visible
                    await renderMoreMessages(); // <-- CHANGED: Added await
                }
            }, options);

            const topLoader = document.getElementById('top-loader');
            if (topLoader) {
                intersectionObserver.observe(topLoader);
            }
        }

        /**
         * Creates a single message element for the chat window.
         */
        async function createMessageElement(messageData) { // <-- CHANGED: Added async
            const messageEl = document.createElement('div');
            messageEl.classList.add('message');

            const bubbleEl = document.createElement('div');
            bubbleEl.classList.add('message-bubble');

            if (messageData.type === 'system') {
                messageEl.classList.add('system');
                bubbleEl.textContent = messageData.message;
            } else {
                // Assign a color ID to the author
                if (!userColors.has(messageData.author)) {
                    userColors.set(messageData.author, colorIndex++);
                }
                const authorId = userColors.get(messageData.author);
                messageEl.setAttribute('data-author-id', authorId % 8); // Cycle through 8 colors

                // Style for sent vs. received
                if (messageData.author === 'You') {
                    messageEl.classList.add('sent');
                } else {
                    messageEl.classList.add('received');
                    const authorEl = document.createElement('div');
                    authorEl.classList.add('author');
                    authorEl.textContent = messageData.author;
                    bubbleEl.appendChild(authorEl);
                }

                // Handle message content (text vs. media)
                const contentEl = document.createElement('div');
                contentEl.classList.add('message-content');
                
                const mediaMatch = messageData.message.match(/<attached: (.+?)>/);
                
                if (mediaMatch) {
                    const fileName = mediaMatch[1];
                    const entry = findFileInZip(fileName);
                    
                    if (entry) {
                        const mediaEl = await createMediaElement(entry, fileName); // <-- CHANGED: Added await
                        contentEl.appendChild(mediaEl);
                    } else {
                        contentEl.textContent = `[Media omitted: ${fileName}]`;
                    }
                } else {
                    // Simple text message
                    contentEl.textContent = messageData.message;
                }
                
                bubbleEl.appendChild(contentEl);

                // Add timestamp
                const timeEl = document.createElement('div');
                timeEl.classList.add('timestamp');
                timeEl.textContent = `${messageData.date}, ${messageData.time}`;
                bubbleEl.appendChild(timeEl);
            }

            messageEl.appendChild(bubbleEl);
            return messageEl;
        }

        /**
         * Creates an <img>, <video>, or <a> element for an attachment.
         */
        async function createMediaElement(entry, fileName) { // <-- CHANGED: Added async
            const wrapper = document.createElement('div');
            wrapper.classList.add('media-attachment');
            
            const fileType = entry.contentType || 'application/octet-stream';
            const fileExtension = fileName.split('.').pop().toLowerCase();
            
            // <-- CHANGED: This section is updated to use async/await
            let blobUrl = '';
            try {
                const arrayBuffer = await entry.arrayBuffer(); // Get data as ArrayBuffer
                const blob = new Blob([arrayBuffer], { type: fileType });
                blobUrl = URL.createObjectURL(blob);
            } catch (e) {
                console.error('Error creating blob URL:', e);
                wrapper.textContent = `[Error loading: ${fileName}]`;
                return wrapper;
            }
            // <-- END OF CHANGES
            
            if (['jpg', 'jpeg', 'png', 'gif', 'webp'].includes(fileExtension)) {
                const img = document.createElement('img');
                img.src = blobUrl;
                img.alt = fileName;
                img.loading = 'lazy'; // Important for performance
                wrapper.appendChild(img);
            } else if (['mp4', 'webm', 'ogg', 'mov'].includes(fileExtension)) { // Added 'mov'
                const video = document.createElement('video');
                video.src = blobUrl;
                video.controls = true;
                video.preload = 'metadata'; // Only load metadata until played
                video.style.width = '100%';
                wrapper.appendChild(video);
            } else {
                // Fallback for other files (PDF, DOCX, etc.)
                const link = document.createElement('a');
                link.href = blobUrl;
                link.download = fileName;
                link.classList.add('file-attachment');
                
                let icon = 'ðŸ“„'; // Default icon
                if (fileExtension === 'pdf') icon = 'PDF';
                if (fileExtension === 'zip') icon = 'ðŸ“¦';
                if (['doc', 'docx'].includes(fileExtension)) icon = 'DOC';
                
                link.innerHTML = `
                    <span class="file-icon">${icon}</span>
                    <div class="file-info">
                        <span class="file-name">${fileName}</span>
                        <span class="file-size">${formatBytes(entry.size)}</span>
                    </div>
                `;
                wrapper.appendChild(link);
            }
            
            return wrapper;
        }

        /**
         * Helper to find a file in the zip entries, ignoring path prefixes
         * that WhatsApp sometimes adds (like "WhatsApp Images/").
         */
        function findFileInZip(fileName) {
            if (zipFileEntries[fileName]) {
                return zipFileEntries[fileName];
            }
            // Try finding just by the basename
            const simpleName = fileName.split('/').pop();
            return Object.values(zipFileEntries).find(entry => entry.name.endsWith(simpleName));
        }

        /**
         * Utility function to format file sizes.
         */
        function formatBytes(bytes, decimals = 2) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const dm = decimals < 0 ? 0 : decimals;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        }

        /**
         * Updates the status bar text.
         */
        function updateStatus(message, isError = false) {
            statusBar.textContent = message;
            statusBar.style.backgroundColor = isError ? '#d9534f' : '#075E54';
        }

        /**
         * Resets the UI to the initial state.
         */
        function resetUI() {
            progressContainer.style.display = 'none';
            progressBar.value = 0;
            chatWindow.innerHTML = '';
            chatWindow.appendChild(dropZone);
            dropZone.style.display = 'block';
            allMessages = [];
            zipFileEntries = {};
            renderedMessagesCount = 0;
        }
        
        /**
         * Drag and drop handlers for the drop zone.
         */
        function handleDragOver(event) {
            event.preventDefault();
            event.stopPropagation();
            dropZone.style.backgroundColor = '#e0e0e0';
        }

        function handleDragLeave(event) {
            event.preventDefault();
            event.stopPropagation();
            dropZone.style.backgroundColor = '#fafafa';
        }
    </script>
</body>
</html>
